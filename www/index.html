<html>
	<head>
		<title>Pure-Java Object Relational Mapping</head>
	</head>

	<body>              
		<script src="https://ssl.google-analytics.com/urchin.js" type="text/javascript">
		</script>
		<script type="text/javascript">
			_uacct = "UA-1070906-4";
			urchinTracker();
		</script>
		
		<h2>Description</h2>
		
		<p>ActiveObjects is an intuitive, pure-Java ORM.  AO is designed from the 
		ground up to be extremely simple and easy to use from an API standpoint.  AO also has 
		the potential to have significantly superior performance to more traditional ORMs such as 
		Hibernate because it is lazy-loaded with a multi-tiered caching system.  AO can be used 
		with either an existing database schema, or it can auto-generate the database schema 
		from the user-specified entity interfaces.</p>
		
		<h4>Example</h4>
		
		<p>The first step in building an application which uses ActiveObjects is to define the
		entities.  This is done in pure Java (no XML configuration).  Tthe entiy definitions are
		database non-specific.</p>
		
<pre>// Person.java
public interface Person {
	public String getName();
	public void setName(String name);
	
	public int getAge();
	public void setAge(int age);
	
	@SQLType(Types.CLOB)
	public String getComment();
	
	@SQLType(Types.CLOB)
	public void setComment(String comment);
	
	public Family getFamily();
	public void setFamily();
	
	@ManyToMany(PersonToPerson.class)
	public Person[] getPeople();
}

// Family.java
public interface Family {
	public String getName();
	public void setName(String name);
	
	@OneToMany
	public Person[] getPeople();
}

// PersonToPerson.java
public interface PersonToPerson {
	public Person getPersonA();
	public void setPersonA(Person person);
	
	public Person getPersonB();
	public void setPersonB(Person person);
}</pre>

		<p>Once we have the entity definitions, the DDL statements can be auto-generated for
		whatever database you may be using.  This is done using the <code>Generator</code> utility.
		Here's what the SQL would look like as generated for the MySQL database.</p>

<pre>CREATE TABLE person (
	id INTEGER NOT NULL AUTO_INCREMENT,
	name VARCHAR(45),
	age INTEGER,
	comment TEXT,
	familyID INTEGER,
	PRIMARY KEY (id),
	FOREIGN KEY (familyID) REFERENCES family(id)
) ENGINE=InnoDB;
CREATE TABLE family (
	id INTEGER NOT NULL AUTO_INCREMENT,
	name VARCHAR(45),
	PRIMARY KEY (id)
) ENGINE=InnoDB;
CREATE TABLE personToPerson (
	id INTEGER NOT NULL AUTO_INCREMENT,
	personAID INTEGER,
	personBID INTEGER,
	PRIMARY KEY (id),
	FOREIGN KEY (personAID) REFERENCES person (id),
	FOREIGN KEY (personBID) REFERENCES person (id)
) ENGINE=InnoDB;</pre>
		
		<p>You'll notice the usage of convention to determine field names, primary and foreign keys,
		etc...</p>
		
		<p>Of course, an ORM layer isn't very useful unless you actually <i>use</i> it.  Here's some
		sample code showing some basic CRUD operations with our new model.</p>

<pre>// ...
EntityManager manager = new EntityManager(DatabaseProvider.getInstance(
		"jdbc:mysql://localhost/ao_test", "user", "password");
		
Family family = manager.create(Family.class);
family.setName("Spiewak");
		
Person me = manager.create(Person.class);
me.setName("Daniel Spiewak");
me.setAge(27);
me.setComment("I love databasing");
me.setFamily(family);

Person you = manager.create(Person.class);
you.setName("Joe Blow");
you.setName(23);
you.setComment("Guess who?");
you.setFamily(family);

PersonToPerson relation = manager.create(PersonToPerson.class);
relation.setPersonA(me);
relation.setPersonB(you);

family.getPeople();		// ...returns new Person[] {you, me}
you.getPeople();		// ...returns new Person[] {me}

// notice, this is the first use of SQL in the whole example
Family[] families = manager.findWithSQL(Family.class, "familyID", "SELECT familyID FROM person");

// returns any person with age >= 18
Person[] overAge = manager.find(Person.class, "age >= ?", 18);

/*
 * notice the varargs parameters, as well as the direct use of an
 * entity instance without worrying about the ID value
 */
Person[] inFamilyOver21 = manager.find(Person.class, "age >= ? AND familyID = ?", 21, family);</pre>
		
		<p>As you see, much of the framework is designed to completely encapsulate
		the developer from the complexities of SQL and even from the precise specifics
		of the schema.  The only place where this rule is broken is in the <code>find</code>
		methods, which are designed to leverage the power of SQL, rather than to
		completely shelter the developer.</p>
	</body>
</html>
