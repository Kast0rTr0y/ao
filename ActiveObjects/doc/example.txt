.. :mode=rest:
=============
Example Usage
=============

The first step in building an application which uses ActiveObjects is to define the
entities.  This is done in pure Java (no XML configuration).  The entity definitions are
database non-specific::

    // Person.java
    public interface Person extends Entity {
        public String getName();
        public void setName(String name);
        
        public int getAge();
        public void setAge(int age);
        
        @SQLType(Types.CLOB)
        public String getComment();
        
        @SQLType(Types.CLOB)
        public void setComment(String comment);
        
        public Family getFamily();
        public void setFamily();
        
        @ManyToMany(PersonToPerson.class)
        public Person[] getPeople();
    }
    
    // Family.java
    public interface Family extends Entity {
        public String getName();
        public void setName(String name);
        
        @OneToMany
        public Person[] getPeople();
    }
    
    // PersonToPerson.java
    public interface PersonToPerson extends Entity {
        public Person getPersonA();
        public void setPersonA(Person person);
        
        public Person getPersonB();
        public void setPersonB(Person person);
    }

Once we have the entity definitions, the DDL statements can be auto-generated for
whatever database you may be using.  This is done using migrations. Here's what the 
DDL would look like as generated for the MySQL database::

    CREATE TABLE family (
        id INTEGER NOT NULL AUTO_INCREMENT,
        name VARCHAR(255),
        PRIMARY KEY (id)
    ) ENGINE=InnoDB;
    
    CREATE TABLE person (
        id INTEGER NOT NULL AUTO_INCREMENT,
        name VARCHAR(255),
        age INTEGER,
        comment TEXT,
        familyID INTEGER,
        PRIMARY KEY (id),
        CONSTRAINT fk_person_familyID FOREIGN KEY (familyID) REFERENCES family(id)
    ) ENGINE=InnoDB;
    
    CREATE TABLE personToPerson (
        id INTEGER NOT NULL AUTO_INCREMENT,
        personAID INTEGER,
        personBID INTEGER,
        PRIMARY KEY (id),
        CONSTRAINT fk_personToPerson_personAID FOREIGN KEY (personAID) REFERENCES person (id),
        CONSTRAINT fk_personToPerson_personBID FOREIGN KEY (personBID) REFERENCES person (id)
    ) ENGINE=InnoDB;
		
You'll notice the usage of convention to determine field names, primary and foreign keys,
etc...

Of course, an ORM layer isn't very useful unless you actually *use* it.  Here's some
sample code showing some basic CRUD operations with our new model::

    // ...
    
    // retrieves an EntityManager relevant to the specified URI
    // if available (i.e. the classpath set appropriately), the connection will be pooled
    EntityManager manager = new EntityManager("jdbc:mysql://localhost/ao_test", "user", "password");
            
    Family family = manager.create(Family.class);
    family.setName("Spiewak");
    family.save();
            
    Person me = manager.create(Person.class);
    me.setName("Daniel Spiewak");
    me.setAge(27);
    me.setComment("I love databasing");
    me.setFamily(family);
    me.save();
    
    Person you = manager.create(Person.class);
    you.setName("Joe Blow");
    you.setAge(23);
    you.setComment("Guess who?");
    you.setFamily(family);
    you.save();
    
    PersonToPerson relation = manager.create(PersonToPerson.class);
    relation.setPersonA(me);
    relation.setPersonB(you);
    relation.save();
    
    family.getPeople();		// ...returns new Person[] {you, me}
    you.getPeople();		// ...returns new Person[] {me}
    
    /*
     * notice, this is the first use of SQL in the whole example, and 
     * it's a contrived usage at that
     */
    Family[] families = manager.findWithSQL(Family.class, "familyID", "SELECT DISTINCT familyID FROM person");
    
    // returns any person with age greater than or equal to 18
    Person[] overAge = manager.find(Person.class, "age >= ?", 18);
    
    /*
     * notice the varargs parameters, as well as the direct use of an
     * entity instance without worrying about the ID value
     */
    Person[] inFamilyOver21 = manager.find(Person.class, "age >= ? AND familyID = ?", 21, family);
		
As you see, much of the framework is designed to completely encapsulate
the developer from the complexities of SQL and even from the precise specifics
of the schema.  The only place where this rule is broken is in the ``find``
methods, which are designed to leverage the full power of SQL, rather than
completely shelter the developer.
